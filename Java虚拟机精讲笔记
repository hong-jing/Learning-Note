------------------------------------------------《Java虚拟机精讲》笔记----------------------------------------------------------
1.Javac编译器的编译步骤：词法解析-语法解析-语义解析-生成字节码
词法解析：将Java源码中的关键字和标识符等内容转换为符合Java语法规范的Token实例，然后按照特定的顺序规则进行匹配校验；
语法解析：将词法解析得到的Token序列整合为一颗结构化的抽象语法树。
语义解析：由于语法解析器所解析出来的语法树并不能直接应用于生成字节码文件，这棵语法树还不完善，语义解析的目的的
就是为了将之前语法解析所产生的语法树扩充得更加完善，后续编译器将会使用语义解析后的语法树来生成字节码。
生成字节码：将复合Java语法规范的Java代码转换为符合JVM规范的字节码文件。
2.Hotspot其实是使用了C++以及混合了少量的C和汇编代码编写而成的。

3.字节码文件
1>.字节码文件的前四个字节为0xCAFEBABE，称之为魔数，魔数就是JVM用于校验所读取的目标文件是否是一个有效且合法的字节码文件。
2>.minor_version(次版本号)和major_version(主版本号)：紧跟在magic后面的四个字节即使编译的次版本号和主版本号，他们共同构成了字节码文件的版本号。
3>.constant_pool_count(常量池计数器)和constant_pool(常量池)：紧跟在次版本号和主版本号后面的就是常量池计数器和常量池，常量池是字节码文件中非常重要的数据项，
同时也是字节码文件中与其他项关联最多和占用字节码空间最大的数据项。
常量池中主要用于存放字面量和符号引用两大类数据常量，其访问方式是通过索引来进行访问的，但由于常量池列表中的常量数并不固定，因此在常量池之前就需要通过一个2个字节的常量池计数器来统计常量池列表中到底拥有多少常量项。
PS：常量池计数器中的计数值并非从0开始计数，而是从1开始计数。
但是0仍是存在的，为了满足后续其他项在不引用常量池中的任何常量项时，可以默认把常量池中的访问索引设置为0.

4.常量池中存放的字面量由文字字符串，final常量值等构成，而符号引用则包括了类和接口的全限定名，字段的名称和描述符，以及方法的名称和描述符。

5.access_flag(访问标志)：紧跟在常量池之后的2个字节就是访问标志，主要用于表示某个类或者接口的访问权限。

6.this_class(类索引)和super_class(超类索引)：紧跟在访问标志之后的4个字节就是类索引和超类索引，他们各自会通过索引指向常量池列表中一个类型为CONATSNT_Class_info的常量项、
CONSTANT_Class_info由tag和name_index两个部分构成，tag是一个具有CONSATNT_Class_info值的常量，而name_index则是个指向常量池列表中类型为CONSTANT_Utf8_info常量项的索引，通过
这个索引值可成功获取到CONSTANT_Utf8_info常量项中全限定名字字符串。
类索引用于确定当前类的全限定名，而超类索引则用于确定当前类的超类全限定名。

7.interfaces_count(接口计数器)和interfaces(接口表)：在类索引和超类索引之后的4个字节就是接口计数器和接口表，接口技术器用于表示当前类或者接口的直接超类接口数量。
接口表实际上是一个数组集合，它包含了当前类或者接口在常量池列表中直接超类接口的 索引集合，通过这个索引即可确定当前类或者接口的超类接口的全限定名。

8.fields_count(字段计数器)和fields(字段表)：紧跟在接口计数器和接口表之后的就是计数器和字段表，字段计数器用于表示一个字节码文件中的fiels_indo表总是，也就是一个类中类变量和实例变量的数量总和。
而字段表实际上则是一个数组集合，字段表中的每一个成员都必须是一个field_info结构的数据项。

9.methods_count(方法计数器)和methods(方法表)：方法计数器用于表示一个字节码文件中的method_info表总数，而方法表实际上则是一个数组集合，方法表中的每一个成员必须是一个method_info结构的数据项。
method_info用于表示当前类或者接口中某个方法的完整描述，比如方法标识符，方法的访问修饰符，方法的返回值类型以及方法的参数信息等。

10.attributes_count(属性计数器)和attributes(属性表)：属性表计数器用于表示当前字节码文件中的attribute_info表总数，而属性表同之前的字段表和方法表一样都是一个集合，属性表中的每一个成员都必须是一个attribute_info结构的数据项，每一个
attribute_info表的第一项都是指向常量池列表中CONSTANT_Utf8_info项的索引。属性可以出现在ClassFile表，字段表和方法表中，用于描述与其相关的信息。

11.Java内存分配和垃圾回收
Java堆区在JVM启动的时候被创建，并且它在实际的内存空间中可以是不连续的。
Java堆区是一块用于存储对象实例的内存区，同时也是GC执行垃圾回收的重点区域。

储存在JVM中的Java对象可以被划分为两类：一类是生命周期较短的瞬时对象，这些对象的创建和消亡都非常迅速，而另外一类对象的生命周期却非常长，在某些极端的情况下还能够和JVM的生命周期保持一致。
Java堆进一步细分的话，还可以分为新生代和老年代，其中新生代又可以划分为Eden空间，From Survivor空间和To Survivor空间。

线程共享的区间：方法区，堆，执行引擎，本地接口
线程私有：Java栈，本地方法栈，程序计数寄存器

方法区中存储了每一个Java类的结构信息，比如运行时常量池，字段，方法数据，构造函数和普通方法的字节码内容以及类，实例，接口初始化时需要用到的特殊方法等数据。
方法区仅仅是逻辑上的独立，实际上还是包含在Java堆区中，也就是说，方法区在物理上当然属于Java堆的一部分。
方法区在JVM启动的时候被创建，并且它在实际的内存空间中和Java堆区一样都可以是不连续的，方法区是一块比较特殊的运行时内存区，也称作为永久代，方法区不会像
Java堆区那样频繁地被GC执行回收，甚至还可以显式指定是否需要在程序运行时回收方法区中的数据。

运行时常量池：
运行时常量池属于方法区中的一部分，一个有效的字节码文件除了包含类的版本信息，字段，方法以及接口等描述信息外，还包含一项信息就是常量池表，那么运行时常量池就是字节码文件中常量池表的运行时表现形式。
当类装载器成功将一个类或者接口装载进JVM后，就会创建与之对应的运行时常量池。由于每一个运行时常量池所分配的内存来源于方法区，一旦所需要的内存大小超过方法区所能够提供的最大值时，运行时常量池也会抛出OOM异常。

程序计数器寄存器：
由于JVM是基于栈的架构，所以任何的操作都需要经过入栈和出栈来完成，JVM的程序计数器寄存器是对物理程序计数寄存器的一种抽象模拟，它是线程私有的，
生命周期与线程的生命周期保持一致。如果当前线程所执行的方法是一个Java方法，那么程序计数寄存器就会存储正在执行的字节码指令地址，反之如果是本地方法，那么程序计数寄存器的值就是空。
JVM的字节码解释器就需要通过改变程序计数寄存器的值来明确下一条应该执行什么样的字节码指令，当然Java虚拟机规范并没有明确要求一定要
采用这种方式去实现。程序计数寄存器是JVM的内存中唯一一个没有明确规定需要抛出OOM异常的运行时内存区。

Java栈：
也称为Java虚拟机栈，同样是线程私有，Java栈用于存储栈帧，而栈帧中所存储的就是局部变量表，操作数栈，以及方法出口等信息。
Java堆中存储的是对象实例，而Java栈中的局部变量表就是用于存储各类原始数据类型，对象引用以及returnAddress类型。returnAddress类型被定义为Java虚拟机内部的原始数据类型，该类型用于表示一条字节码指令的操作码，
但returnAddress类型在Java语言中却不存在相对应的类型，同时自然也就无法再运行时更改returnAddress类型的值。
Java栈允许被实现成固定大小的内存或者是可动态扩展的内存大小，如果Java栈被设定为固定大小的内存，一旦线程请求分配的栈容量超过JVM所允许的最大值时，JVM会抛出一个StackOverflowError异常，反之抛出一个OOM异常。

本地方法栈：
本地方法栈用于支持本地方法，比如使用C/C++编写的方法的执行，它和Java栈的作用类似，一旦JVM中实现由本地方法栈时，那么它将会和Java栈一样，运行被实现成固定或者是可动态扩展的内存大小，并且本地方法栈同样也会抛出StackOverflowError和OOM异常。

12.内存分配原理：
JVM中包含三种引用类型，分别是类类型，数组类型和接口对象，这些引用类型的值分别由类实例，数组实例，以及实现了某个接口的派生派生类实例负责动态创建。

JVM中创建一个对象的过程：
JVM首先会检查这个new指令的参数能否在常量池中定位到一个类的符号引用，然后检查与这个符号引用相对应的类
是否已经成功经历过加载，解析和初始化等步骤，当类完成了装载步骤之后，就已经完全可以确定出创建对象实例时所需要的内存空间大小，接下来JVM将会对其进行内存分配，以存储所生成的对象实例。
由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆中划分内存空间是非线程安全的，所以务必需要保证数据操作的原子性。基于线程安全的考虑，如果一个类在内存分配之前已经成功完成类的装载步骤之后，
JVM就会有限选择在TLAB(Thread Local Allocation Block,b本地线程分配缓冲区)中为对象实例分配内存空间，TLAB在Java堆中是一块线程私有区域，它包含在Eden空间内，除了可以避免一系列的非线程安全问题外，同时还能够提升内存分配的吞吐量，因此我们可以将
这种内存分配方式称之为快速分配策略。TLAB占Eden的1%，我们可通过-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。一旦对象在TLAB空间分配内存失败时，JVM就会尝试通过加锁机制保证数据操作的原子性，从而直接在Eden空间中分配内存，如果再Eden中也
无法分配时，JVM就会执行Minor GC（新生代的GC），直至最终可以在Eden空间中分配内存为止，如果是大对象则直接分配在老年代中。
当为对象成功分配好所需的内存空间后，JVM接下来要做的就是初始化对象实例，JVM首先会对分配后的内存空间进行零值初始化，这一步操作确保了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能够访问这些字段的数据类型所对应的0值。之后JVM就会初始化对象头和实例数据，最后将对象引入栈后再更新程序计数寄存器
中的字节码指令地址。

13.逃逸分析和栈上分配
逃逸分析是JVM在执行性能优化之前的一种技术。具体目标就是分析出对象的作用域。简单来说，当一个对象被定义在方法体内部之后，它的访问权限仅限于方法体内，一旦其引用被外部成员引用后，这个对象就因此发生了逃逸。反之
如果定在在方法体内的对象并没有被任何外部成员引用时，JVM就会为其在栈帧中分配内存空间。

由于对象直接在栈上分配内存，因此GC就无需执行垃圾回收，栈帧会伴随着方法的调用而创建，伴随方法的执行结束而销毁。因此栈上分配的内存所占用的内存空间将会随着栈帧的出栈而释放。

14.GC的作用
GC的工作任务有两大块：内存的动态分配和垃圾回收。
垃圾标记算法：计数算法和根搜索算法（可达性分析）：由于计数算法会存在一些明显已经死亡了的对象尽管没有被任何的存活对象引用，但是他们彼此之间却存在相互引用时，引用计数器中的值则永远不会为0，这样会导致GC在执行内存回收时永远无法释放掉无用对象所占用的内存空间，
导致内存泄漏。
根搜索算法则是索引能够被根对象集合直接或者间接连接的对象才是存活对象，不然则标记为死亡对象。
根对象集合中包含了：Java栈中的对象引用；本地方法栈中的对象引用；运行时常量池中的对象引用；方法区中类静态属性的对象引用。与一个类对应的唯一数据类型的class对象。

15.GC算法的工作过程以及优劣分析
标记清除算法：分为两个阶段：垃圾标记和内存释放。
缺点：由于被执行内存回收的无用对象所占用的内存空间有可能是一些不连续的内存块，不可避免会产生一些内存碎片，从而导致后续没有足够的可用内存空间分配给较大的对象。

Java堆可分为新生代和老年代，其中新生代又可以划分为Eden空间，From Survivor空间和To Survivor空间。在Hotspot中，Eden和另外两个Survivor空间缺省所占比例是8:1,；

复制算法：JVM中绝大多数对象都是瞬时状态，生命周期非常短暂，所以复制算法被广泛应用于新生代中。
当执行一次Minor GC(新生代的GC)时，Eden空间中存活对象会被复制到To空间中，并且之前已经经历过一次Minor GC并在From空间存活下来的对象如果还年轻的话也会被复制到To空间内。
在两种特殊的情况下，Eden和From空间中存活的对象将不会被复制到To空间内：1.首先是如果存活对象的分代年龄超过选项“-XX:MaxTunuringThreshold”所指定的阈值时，将会直接晋升到老年代中。
其次当To空间的容量达到阈值时，存活对象同样也是直接晋升到老年代中。
当执行玩MInor GC后，Eden和From空间将会被清空，而存活下来的对象将会全部存储在To空间内，接下来From空间和To空间将会互换位置(使每次GC时都直接在Eden和From中进行)。
其实复制算法就是拿To空间作为一个临时的空间交换角色，务必保证两块Survivor空间中有一块必须是空的。不适用于老年代。

标记-整理算法：当成功标记处内存中的垃圾对象后，该算法会将所有的存活对象都移动到一个规整且连续的内存空间中，然后执行Full GC（老年代的垃圾回收，或者称之为Major GC）回收无用对象
所占用的内存空间。当成功执行压缩后，已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，则可以使用指针碰撞技术修改指针的偏移量将新对象分配在第一个
空闲内存位置，为新对象内存分配带来便捷。

16.类加载机制
任何一个类型在使用之前都必须经历过完整的加载，连接和初始化三个类加载步骤。
类加载器的主要任务就是根据一个类的全限定名来读取此类的二进制字节流到JVM内部，然后转换为一个与目标类对应的Java.lang.class对象实例。

17.常见的三个类加载器：Bootstrap ClassLoader,ExtClassLoader,AppClassLoader
BootstrapClassLoader也称为启动类加载器，由C++编写并嵌套在JVM内部，主要负责加载JAVA_HOME/lib下的所有类型，或者是由选项“-Xbootclasspath”指定路径中所有类型。
Extclassloader和APPClassLoader派生于ClassLoader，并且都是采用Java语言进行编写的，前者主要负责加载Java_home/lib/ext扩展目录中的所有类型，而后者则主要负责加载ClassPath目录中的所有类型。

双亲委派模型：当一个类加载器接收到一个类加载任务时，它不会立即展开加载，而是将加载任务委派给其超类加载器去执行，每一层的类加载器都会采用相同的方式，知道委派给最顶层的启动类加载器位置。
如果超类加载器无法加载委派给它的类时，便会将类的加载任务退回给它的下一级类加载器去执行加载。

18.类的加载过程：加载-->链接(验证，准备，解析)-->初始化
类的加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区中的方法区内，然后将其转换成一个与目标类型对应的java.lang.class对象实例（Hotspot VM选择将class对象存储在方法区内），
这个class对象在日后就会作为方法区中该类的各种数据的访问入口；而链接阶段要做的就是将已经加载到JVM中的二进制字节流的类数据信息合并到JVM的运行时状态中，
然而链接阶段有验证，准备，解析三个阶段组成，其中验证阶段的主要任务就是验证类数据信息是否符合JVM规范，是否是一个有效的字节码文件，而验证的内容则涵盖了类数据信息的格式校验，
语义分析，操作验证等。准备阶段的主要任务就是为类中的所有静态变量分配内存空间，并为其设置一个初始值（）由于还没有对象产生，因此实例变量将不在此操作范围内）；而解析阶段的主要任务就是将常量池中所有的符号引用全部转换为直接
引用，不过Java虚拟机并没有明确要求解析阶段一定要按顺序执行，因此解析阶段可以等到初始化之后再执行。类加载过程的最后一个阶段就是初始化，在这个阶段，JVM会将一个类中所有被static关键字标示的代码统统执行一遍，如果执行的是静态变量，
那么就会使用用户指定的值覆盖掉之前在准备阶段中JVM为其设置的初始值，然后如果程序中没有为静态变量显示指定赋值操作，那么所有持有的值仍是之前的初始值；反正如果执行的是static代码块，那么在初始化阶段中，JVM就将会执行static代码块中定义
的所有操作。

19.尽管一个类在初始化操作之前必须要求它的超类提前完成初始化操作，但是对于接口而言，这条规则并不适用。只有在某个接口中声明的非常量字段被使用时，该接口才会被初始化，而不会因为实现这个接口的派生接口或者派生类要初始化而被初始化，也就是
说，接口并不要求在执行初始化操作的时候，它的超类接口必须提前完成初始化操作。

20.在HotspotVM中，加载、验证、准备、和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再
执行，除此之外，验证阶段中的一些验证操作将会和加载阶段一起执行，而不会等待加载完成之后才会执行某些验证操作。
验证阶段JVM大致可分为：格式验证，语义分析，操作验证以及符号引用验证等。

21.只有成功通过格式验证后，类加载器才会成功将类的二进制信息加载到方法区中，而后续的其他验证操作都直接在方法区中进行。
对元数据进行验证：检查一个被标记为final的类型是否包含派生类；检查一个类的final方法是否被派生类进行重写；确保超类与派生类之间
没有不兼容的一些方法声明。

22.准备阶段：为类的所有静态变量分配内存空间，并为其设置一个初始值，而非用户手动执行赋值操作。

23.解析阶段：解析阶段可以等到初始化之后再执行，解析阶段的主要任务就是将字节码常量池中的符号引用全部转换为直接引用，包括类、接口、方法和字段的符号引用。

24.初始化阶段：JVM会将所有被static关键字标示的代码统统执行一遍，如果执行的是静态变量，那么就会使用用户指定到的值覆盖掉之前在准
备阶段中JVM为其设置的初始值，当然如果再程序中并没有为静态变量显示指定赋值操作，那么所持有的值仍然是之前的初始值；反之则是static
代码块。
初始化阶段是真正执行类中定义的Java程序代码的过程，初始化过程是一个执行类构造器<clinit>()方法的过程，根据程序员通过程序制定的主观计划
去执行初始化类变量和其他资源，其实初始化阶段要做的事就是给static变量赋予用户指定的值以及执行静态代码块。
PS：VM会保证类的初始化在多线程环境中被正确地加锁，同步，即如果多个线程同时去初始化一个类，那么只会有一个类去执行这个类的<clinit>()
方法，其他线程都要阻塞，直至活动线程执行<clinit>()方法完毕。因此如果再一个类的<clinit>()方法中有耗时很长的操作，就有可能造成多个进程阻塞。不过
其他线程虽然会阻塞，但是执行<clinit>()方法的那条线程退出<clinit>()方法之后，其他线程不会再次进入<clinit>()方法，因为同一个类加载器下，
一个类只会初始化一次。

Java 虚拟机规范规定了5种场景必须立即对类进行初始化（对一个类进行主动引用）：
1.使用new关键字实例化对象，读取或者设置一个类的静态字段（被final修饰的静态字段除外），调用一个类的静态方法时候。(new关键字。反射或者序列化)
2.使用Java.lang.reflect包中的方法对类进行反射调用的时候。
3.初始化一个类，发现其父类还没有初始化过的时候
4.虚拟机启动的时候，虚拟机会先初始化用户指定的包含main()方法的那个类。
（也有的说调用一个类型或者接口的静态字段，或者对这些静态字段进行赋值操作时）
除上面的四种场景外，所有的引用类的方式都不会触发类的初始化，称为被动引用。

第八章剖析Hotspot的架构模型与执行引擎
25.HotSpot采用解释器和即时编译器并存的架构，当虚拟机启动时，解释器可以首先发挥作用，而不会等待即时编译器全部编译完再执行，这样可以省去许多不必要的编译时间，并且随着程序
运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令。

26.Java栈也被称为虚拟机栈，它同程序计数寄存器一样都是线程私有的，并且生命周期与线程安全周期保持一致。java栈主要用于存储栈帧，而栈帧中则负责存储局部变量表，操作数栈，动态链接和方法返回值等信息。
栈帧是支持JVM调用/执行程序方法的数据结构，它是方法执行环境，每一个方法被调用时都会创建一个独立的栈帧以便维系所需的各种数据信息，栈帧伴随着方法的调用而创建，伴随方法的结束而销毁，那么每一个方法从
调用到执行结束的过程，就对应着Java栈中一个栈帧从入栈到出栈的过程，并且无论方法的调用状态是否正常都算作是方法结束。在此需要注意，不用线程总所包含的栈帧是不允许存在相互引用的。

27.在栈帧中，局部变量表和操作数栈左旭的容量大小在编译期就可以完全被确定下来，并保存在方法的code属性中，也就是说，栈帧究竟需要分配多大的内存空间完全取决于具体的JVM实现和方法调用时分配的实际内存。

28.局部变量表：局部变量表主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类原始数据类型，对象引用，以及返回地址类型。局部变量表所需的容量大小在编译期就可以被完全确定下来，并保存在
方法的code属性中。
定义在方法体外（也即是类的成员变量），不只是作用域发生了变化，更重要的是，其值也并非还是存储在局部变量表里，而是存储在对象内存空间的实例数据中，整体来看即存在Java堆中。
简单来说，与线程上下文相关的数据存在Java栈中，反之存在Java堆中。
局部变量表中最小的的存储单元是slot，一个slot可以存储一个类型为boolean,byte,char,short,float,reference以及returnAddress小于或等于32bit的数值，2个slot可以存储一个类型为long，或double的64bit的数值。JVM
会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，访问索引从0开始到小于局部变量表最大的slot长度。
由于long和double类型的二进制位数都是64bit，那么当使用这两个类型存储数据时，理论上占用两个连续的slot。如果需要访问局部变量表中一个64bit的局部变量值是，只需要索引第一个即可。

一个slot占用多大的内存空间在Java虚拟机规范中未明确要求，但最好使用32bit的内存空间存储boolean,byte,char,float,reference以及returnAddress等类型的值，当然这并不会意味着slot的内存大小就固定为32bit，因为slot的内存
大小允许根据处理器，OS，或JVM实现的不同而产生变化。

JVM使用局部变量表来完成方法调用时参数的传递，当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上，访问索引为0的slot一定存储的是与被调用实例方法相
对应的引用，而后续的其他方法参数和方法体内定义的成员变量则会按照顺序从局部变量表中索引为1的slot位置处展开复制。

29.操作数栈：每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以被称为表达式栈。操作数栈采用和局部变量表不一样的访问数据的方式，是基于标准的入栈和出栈操作来完成一次数据访问。每一个操作数栈都会拥有一个明确
的栈深度用于存储数值。一个32bit的数值可以用一个单元的栈深度来存储，而2个单元的栈深度则可以保存一个64bit的数值。当然操作数栈所需的容量大小在编译期就可以被完全确定下来，并保证存在方法的code属性中。

对于byte，short，char类型的值在入栈之前，会被转换成int类型。

30.动态链接：指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。
在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，那么在这种情况下降调用方法的符号引用转换为直接引用的过程称为静态链接。

31.Hotspot的架构：Hotspot内部采用的是解释器和JIT编译器并存的方案共同执行字节码指令，当JVM启动的时候，解释器首先发挥作用，而不必等待编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，JIT编译器将会逐渐发挥它的作用，
根据热点探测功能，将有价值的字节码编译为本地机器指令，换取更高的程序执行效率。

32.寄存器架构和栈式架构之间的区别
根据指令操作方式的不同，可将指令分为零地址指令，一地址指令，二地址指令和三地址指令等n地址指令。
指令集不同：在大部分情况下，基于寄存器架构的指令往往都以一地址指令，二地址和三地址为主，而基于栈式架构的指令却是以零地址指令为主。
其实零地址指令意味着数据源和存储目标都是隐含参数，其实现就是依赖于一种被称为栈的数据结构。

32.零地址指令的好处：零地址指令相比其他形式的指令会显得更加紧凑，因为在一个字节码文件中，除了处理2个表跳转的指令外，其他都是按照8位字节进行对齐的，操作码可以只占一个字节大小。
但是它完成一个操作却往往需要比二地址，三地址指令花费更多的出栈和入栈指令。
基于栈式架构的优点：设计和实现更简单，适用于资源受限的系统
避开了寄存器的分配难题
指令集更加紧凑

基于寄存器架构的优点(比如Android的Dalvik)：性能优秀和执行高效；花费更少的指令去完成一项操作。

33.解释器和JIT编译器
Hotspot VM中采用了即时编译器，那么这就意味着将字节码编译为本地机器指令是一件运行时任务，在Hotspot中内嵌有两个JIT编译器，分别是Client Compiler和Server Comipler，但大多数情况下我们简称为C1编译器和C2编译器。
C1编译器会对字节码进行简单和可靠的优化，以达到更快的编译速度，而C2编译器会启动一些编译耗时更长的优化，以获取更好的编译质量。

33.解释器的任务：就是负责将字节码指令解释为对应平台的本地机器指令执行，在Hotspot VM中，解释器主要由Interpreter模块和Code模块构成，其中interpreter模块实现了解释器的核心功能，该模块中主要包括了两种类型的解释器，分别为模板解释器和C++解释器。而Code模块
主要用于管理Hotspot VM在运行时生成的本地机器指令。

interpreter模块：此模块实现了解释器的核心功能，并且主要包括了两种类型的解释器，分别为模板解释器和C++解释器。在Hotspot中，模板解释器和C++解释器分别由interpreter模块
中的TemplateInterpreter子模块和CppInterpreter子模块实现。

Code模块：主要用于管理Hotspot VM在运行时生成的本地机器指令，在Code模块中，不得不提及的就是CodeCache子模块，该模块也被称为代码缓存模块，主要用于缓存由Hotspot在运行时生成的本地机器指令。
当Java虚拟机启动时，会在内存空间中为其分配一块内存缓存区域，专门用于缓存本地机器指令，该空间与方法区一起合称为非堆内存。

